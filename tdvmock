import sys
from unittest.mock import MagicMock, patch
import pytest

# --- FIX #1: Mock awsglue before importing your main module ---
sys.modules["awsglue"] = MagicMock()
sys.modules["awsglue.utils"] = MagicMock()

from awsglue.utils import getResolvedOptions
getResolvedOptions.return_value = {
    "OSS_ENV": "dev",
    "DATABASE_NAME": "mydb_V",
    "TABLE_NAME": "mytable",
    "SERVER": "myserver",
    "secret_name": "my-secret",
    "BUCKET_NAME": "my-bucket",
    "JOB_RUN_ID": "run-12345"
}


# --- Fixture to patch all external AWS / Spark / JDBC dependencies ---
@pytest.fixture(autouse=True)
def patch_everything():
    with patch("boto3.resource") as mock_boto3_resource, \
         patch("boto3.session.Session") as mock_boto3_session, \
         patch("teradatasql.connect") as mock_td_connect, \
         patch("pyspark.sql.SparkSession") as mock_spark_session:

        # Mock S3
        mock_s3_obj = MagicMock()
        mock_s3 = MagicMock()
        mock_s3.Object.return_value = mock_s3_obj
        mock_boto3_resource.side_effect = lambda service: {
            "s3": mock_s3,
            "dynamodb": MagicMock(Table=MagicMock(return_value=MagicMock()))
        }[service]

        # Mock SecretsManager
        mock_secrets_client = MagicMock()
        mock_secrets_client.get_secret_value.return_value = {
            'SecretString': '{"username": "tduser", "password": "tdpass"}'
        }
        mock_session = MagicMock()
        mock_session.client.return_value = mock_secrets_client
        mock_boto3_session.return_value = mock_session

        # Mock Spark
        mock_spark = MagicMock()
        mock_df = MagicMock()
        mock_df.count.return_value = 1
        mock_df.toPandas.return_value.sort_values.return_value = MagicMock(
            __getitem__=lambda self, key: ["col1 INT", "col2 STRING"],
            to_list=lambda: ["col1 INT", "col2 STRING"],
            index=[0, 1]
        )
        spark_reader = MagicMock()
        spark_reader.option.return_value = spark_reader
        spark_reader.load.return_value = mock_df
        mock_spark.read.format.return_value = spark_reader
        mock_spark_session.builder.appName.return_value.config.return_value.config.return_value.config.return_value.config.return_value.getOrCreate.return_value = mock_spark

        # Mock Teradata connect
        mock_cursor = MagicMock()
        mock_conn = MagicMock()
        mock_conn.cursor.return_value = mock_cursor
        mock_td_connect.return_value = mock_conn

        yield


# --- FIX #2: Patch internal methods to isolate AWS and DB calls ---
@patch("your_module.Db_Config_Create.get_tdv_creds", return_value=("tduser", "tdpass"))
@patch("your_module.Db_Config_Create.func_tdconnect")
@patch("your_module.Db_Config_Create.update_audit_table")
def test_write_to_s3(mock_update_audit, mock_tdconn, mock_get_creds):
    from your_module import Db_Config_Create  # replace with actual module name!

    instance = Db_Config_Create()
    instance.write_to_s3()

    mock_update_audit.assert_called_with(
        "run-12345", "mydb_V", "mytable", "Success", ""
    )
